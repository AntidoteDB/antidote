defmodule Vax.AdapterIntegrationTest do
  use ExUnit.Case, async: true

  defmodule TestRepo do
    use Ecto.Repo, adapter: Vax.Adapter, otp_app: :vax
  end

  defmodule MySchema do
    use Vax.Schema

    schema "my_schema" do
      field(:name, :string)
      field(:age, :integer)
      field(:number_of_friends, :integer, default: 2)
      field(:number_of_followers, :integer)
    end
  end

  setup_all %{} do
    address = Application.get_env(:vax, :address)
    port = Application.get_env(:vax, :port)

    start_supervised!({TestRepo, address: address, port: port})

    :ok
  end

  test "checking out a connection" do
    refute TestRepo.checked_out?()

    TestRepo.checkout(fn ->
      assert TestRepo.checked_out?()
    end)

    refute TestRepo.checked_out?()
  end

  test "performing actions on checked out connection" do
    TestRepo.checkout(fn ->
      id = Ecto.UUID.generate()
      assert 0 = TestRepo.read_counter(id)
      assert :ok = TestRepo.increment_counter(id, 10)
      assert 10 = TestRepo.read_counter(id)
      assert :ok = TestRepo.increment_counter(id, 20)
      assert 30 = TestRepo.read_counter(id)
    end)
  end

  test "reading and increasing a counter" do
    id = Ecto.UUID.generate()
    assert 0 = TestRepo.read_counter(id)
    assert :ok = TestRepo.increment_counter(id, 10)
    assert 10 = TestRepo.read_counter(id)
    assert :ok = TestRepo.increment_counter(id, 20)
    assert 30 = TestRepo.read_counter(id)
  end

  test "inserting an entry" do
    id = Ecto.UUID.generate()
    {:ok, %MySchema{id: ^id} = entry} = TestRepo.insert(%MySchema{id: id, name: "Carl", age: 26})
    %MySchema{id: ^id, name: "Carl", age: 26} = TestRepo.get(MySchema, entry.id)
  end

  test "inserting an entry with autogenerated id" do
    {:ok, %MySchema{id: id} = entry} = TestRepo.insert(%MySchema{name: "Carl", age: 26})
    %MySchema{id: ^id} = TestRepo.get(MySchema, entry.id)
  end

  test "updating an entry" do
    {:ok, entry} = TestRepo.insert(%MySchema{name: "Carl", age: 26})

    {:ok, %{age: 27}} =
      entry
      |> Ecto.Changeset.change(age: 27)
      |> TestRepo.update()

    %MySchema{age: 27, name: "Carl"} = TestRepo.get(MySchema, entry.id)
  end

  test "get returns nil for inexistent keys" do
    assert is_nil(TestRepo.get(MySchema, Ecto.UUID.generate()))
  end

  describe "all" do
    import Ecto.Query

    setup do
      {:ok, entry_a} = TestRepo.insert(%MySchema{name: "John", age: 19})
      {:ok, entry_b} = TestRepo.insert(%MySchema{name: "Alice", age: 22})

      {:ok, entry_a: entry_a, entry_b: entry_b}
    end

    test "can handle `where` with `:==`", %{entry_a: entry_a} do
      assert [] = from(MySchema, where: [id: ^Ecto.UUID.generate()]) |> TestRepo.all()
      assert [%MySchema{} = result] = from(MySchema, where: [id: ^entry_a.id]) |> TestRepo.all()
      assert entry_a.id == result.id
    end

    test "can handle `where` with `in`", %{entry_a: entry_a, entry_b: entry_b} do
      list = [entry_a.id, entry_b.id, Ecto.UUID.generate()]

      assert [result_a, result_b] =
               from(MySchema)
               |> where([m], m.id in ^list)
               |> TestRepo.all()

      assert result_a.id in [entry_a.id, entry_b.id]
      assert result_b.id in [entry_a.id, entry_b.id]
    end

    test "can handle `where` expressions with `or`", %{entry_a: entry_a, entry_b: entry_b} do
      [result_a, result_b] =
        from(MySchema)
        |> where([m], m.id == ^entry_a.id or m.id == ^entry_b.id)
        |> TestRepo.all()

      assert result_a.id in [entry_a.id, entry_b.id]
      assert result_b.id in [entry_a.id, entry_b.id]
    end

    test "raises if trying to use `where` with non pk field" do
      assert_raise(
        RuntimeError,
        "Vax only supports filtering by primary key in where expressions",
        fn ->
          from(MySchema)
          |> where([m], m.age == ^10)
          |> TestRepo.all()
        end
      )
    end

    test "raises if trying to use multiple `where` expressions", %{
      entry_a: entry_a,
      entry_b: entry_b
    } do
      assert_raise(RuntimeError, ~r/Vax only supports a single/, fn ->
        from(MySchema)
        |> where([m], m.id == ^entry_a.id)
        |> where([m], m.id == ^entry_b.id)
        |> TestRepo.all()
      end)
    end

    test "raises if trying to use invalid `where` expression", %{entry_a: entry_a} do
      assert_raise(RuntimeError, ~r/Unsupported expression/, fn ->
        # `and` is one of the unsupported expressions
        from(MySchema)
        |> where([m], m.id == ^entry_a.id and m.id == ^entry_a.id)
        |> TestRepo.all()
      end)
    end
  end

  # FIXME: reset operation seem to be sent correctly, but doesn't take effect
  test "deleting a schema entry" do
    {:ok, %{id: id} = entry} = TestRepo.insert(%MySchema{name: "Carl", age: 25})
    {:ok, %MySchema{id: ^id}} = TestRepo.delete(entry)
    nil = TestRepo.get(MySchema, id)
  end
end
