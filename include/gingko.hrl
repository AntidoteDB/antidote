%TODO link to antidote_crdt types

-type key() :: term().
-type op() :: {update, {key(), type(), term()}} | {read, {key(), type()}}. %TODO what is the term in update?
-type type() :: atom(). 
-type downstream_record() :: term(). 
-type snapshot() :: term().
-type bucket() :: term().
-type txid() :: term().
-define(BUCKET, "antidote").


%% Module names to be used across implementation.
-define(CACHE_DAEMON, cache_daemon).
-define(LOG_INDEX_DAEMON, log_index_daemon).
-define(LOGGING_MASTER, gingko_op_log).


%% Version of log records being used
-define(LOG_RECORD_VERSION, 0).

-record(op_number, {
    %% TODO 19 undefined is required here, because of the use in inter_dc_log_sender_vnode.
    %% The use there should be refactored.
    node :: undefined | {node(), dcid()},
    global :: undefined | non_neg_integer(),
    local :: undefined | non_neg_integer()
}).

-type op_name() :: atom().
-type op_param() :: term().
-type effect() :: term().
-type dcid() :: 'undefined' | {atom(),tuple()}. %% TODO, is this the only structure that is returned by riak_core_ring:cluster_name(Ring)?
-type snapshot_time() :: 'undefined' | vectorclock:vectorclock().
-type clock_time() :: non_neg_integer().
-type dc_and_commit_time() :: {dcid(), clock_time()}.
-type op_num() :: non_neg_integer().
-type op_id() :: {op_num(), node()}.
-type payload() :: term().
-type partition_id() :: ets:tid() | integer(). % TODO 19 adding integer basically makes the tid type non-opaque, because some places of the code depend on it being an integer. This dependency should be removed, if possible.
-type log_id() :: [partition_id()].
%%chash:index_as_int() is the same as riak_core_apl:index().
%%If it is changed in the future this should be fixed also.
-type index_node() :: {chash:index_as_int(), node()}.


-record(materialized_snapshot, {
    %% This is the opid of the latest op in the list
    %% of ops for this key included in this snapshot
    %% before an op that was not included, so to a new
    %% snapshot will be generated by starting from this op
    last_op_id :: op_num(),
    value :: snapshot()
}).


-record(clocksi_payload, {
    key :: key(),
    type :: type(),
    op_param :: effect(),
    snapshot_time :: snapshot_time(),
    commit_time :: dc_and_commit_time(),
    txid :: txid()
}).

-type clocksi_payload() :: #clocksi_payload{}.
-record(commit_log_payload, {
    commit_time :: dc_and_commit_time(),
    snapshot_time :: snapshot_time()
}).

-record(update_log_payload, {
    key :: key(),
    type :: type(),
    bucket :: term(), %TODO Get rid of that entry?
    op :: op()
}).

-type reason() :: term().
-type preflist() :: riak_core_apl:preflist().
-type cache_id() :: ets:tab().


-record(abort_log_payload, {}).

-record(prepare_log_payload, {prepare_time :: non_neg_integer()}).

-type any_log_payload() :: #update_log_payload{}
                         | #commit_log_payload{}
                         | #abort_log_payload{}
                         | #prepare_log_payload{}.

-record(log_operation, {
    tx_id :: txid(),
    op_type :: update
             | prepare
             | commit
             | abort
             | noop,
    log_payload :: any_log_payload()
}).


%% The way records are stored in the log.
-record(log_record, {
    %% The version of the log record, for backwards compatibility
    version :: non_neg_integer(),
    op_number :: #op_number{},
    bucket_op_number :: #op_number{},
    log_operation :: #log_operation{}
}).

-type continuation() :: disk_log:continuation() | start.


-record(log_read, {
  log_entry :: {integer(), #log_record{}},
  continuation:: continuation()
}).


-record(log_index,{
  key :: atom(),
  snapshot_time:: snapshot_time(),
  continuation:: continuation()
}).


-record(cache_object, {
  key:: atom(),
  type:: antidote_crdt:typ(),
  snapshot_time:: snapshot_time(),
  snapshot:: snapshot(),
  count:: integer()

}).